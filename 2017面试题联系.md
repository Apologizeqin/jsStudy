# 2017前端面试题，查到不太会的，就去复习

### 谈谈 你对前端安全的理解，有什么，怎么防范。(不知道如果从网络安全这一方面回答有没有错)

前端的安全问题主要有XSS攻击和CSRF攻击 

XSS(Cross Site Scripting)       跨站脚本攻击      它允许恶意web用户将代码植入到提供给其他用户使用的 页面中。

分为三类   本地利用漏洞    张三给李四发了一个恶意构造了web的url     李四打开后  恶意页面中的js打开一个带有漏洞的html并将其安装在李四的电脑上

​                  反射式漏洞

​	           存储式漏洞

CSRF(跨站请求伪造)

​		在完成一次CSRF经历的事情     是登录受信任的网站 A，并在本地生成cookie，在不退出的情况下，访问了危险网站B。

​	CSRF攻击是源于WEB的隐式身份验证机制，web的身份验证机制虽然可以抱枕一个请求是源于某个客户的浏览器，单却无法保证该请求是用户批准发送的。

​	防御 : 在客户端页面增加伪随机数。

**使用箭头函数需要注意什么**

​    要求动态上下文的时候不能使用   比如说是 定义方法    用构造器创建对象      处理时间时用this获取目标

#### webpack.load的原理  这个不太了解

#### let const

let  形成的是快级作用域       还有let在for循环里面每次迭代的话，都会重新进行赋值

const是一个常量   但是如果是一个对象的话，可以改变对象的属性值

#### css3中的box-sizing 的理解

一共有三个值     分别是   content-box    只计算内容  

​					padding-box    吧padding计算在呢

​						border-box    吧padding和border都包括在内

#### 说说h5中有趣的标签

如果标签语义话，有利于SEO（搜索引擎优化）,搜索引擎会很容易读懂网页要表达的意思    例如文本模块就要使用标题h1 -- h6 列表标签要使用ul和ol ，总要的文字用strong。  总之要充分利用html标签完成他们的本职工作

#### js实现继承有那些方式

借用构造函数实现继承

```js
function person(){
    this.name = 'person1'
}
function child(){
    person1.call(this)
  	this.type = 'child'
}
实现的是部分继承
```

借用原型链实现继承(原型对象的属性是共享的

混合式继承

#### 当new Foo()时发生了什么

创建了一个新对象  

将this指向这个新对象

执行构造函数里面的代码

返回新对象（this）

#### 同源和跨域

限制从一个源加载的文档或脚本 如何与另外一个源的资源进行交互。

一个源指的是主机名，协议和端口好的组合，必须相同

jsonp 基本原理: 利用script标签的异步特性实现

​				给服务器传一个回掉函数，服务器返回一个传递过去的回调过去的回掉函数名称的js代码；

原型和闭包的相关问题？

#### 原型是什么？

原型是一个普通的对象，每一个对象都有一个原型，原型能存储我们的方法，构造函数创建出来的实例对象能够应用原型中的方法。

#### 查看原型 

  以前的时候使用的是__proto__属性，es6用的是Object.getPrototypeof();方法来获取对象的原型，

#### 闭包是什么

当一个内部函数被其外部函数之外的变量应用时，就形成了一个闭包；

闭包的特性

1.函数嵌套函数

2.函数内部可以应用外部的参数和变量

3.参数和变量不会被垃圾回收机制回收。

使用场景

希望在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会污染全局变量。

用一个例子来显示背包

```js
function foo(){
    var a = 2;
  	function bar(){
        console.log(a);
    }
  	return bar;
}
var baz = foo();
baz();
```

#### call方法和apply方法的区别

语法：call(thisobj)

​		调用对象的一个方法，以另一个对象代替当前对象

​		说明:  call方法可以用来代替另一个对象调用一个方法。call方法可以讲一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。

​		如果没有			





