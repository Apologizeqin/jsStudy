# 2017前端面试题，查到不太会的，就去复习

### 谈谈 你对前端安全的理解，有什么，怎么防范。(不知道如果从网络安全这一方面回答有没有错)

前端的安全问题主要有XSS攻击和CSRF攻击 

XSS(Cross Site Scripting)       跨站脚本攻击      它允许恶意web用户将代码植入到提供给其他用户使用的 页面中。

分为三类   本地利用漏洞    张三给李四发了一个恶意构造了web的url     李四打开后  恶意页面中的js打开一个带有漏洞的html并将其安装在李四的电脑上

​                  反射式漏洞

​	           存储式漏洞

CSRF(跨站请求伪造)

​		在完成一次CSRF经历的事情     是登录受信任的网站 A，并在本地生成cookie，在不退出的情况下，访问了危险网站B。

​	CSRF攻击是源于WEB的隐式身份验证机制，web的身份验证机制虽然可以抱枕一个请求是源于某个客户的浏览器，单却无法保证该请求是用户批准发送的。

​	防御 : 在客户端页面增加伪随机数。

**使用箭头函数需要注意什么**

​    要求动态上下文的时候不能使用   比如说是 定义方法    用构造器创建对象      处理时间时用this获取目标

#### webpack.load的原理  这个不太了解

#### let const

let  形成的是快级作用域       还有let在for循环里面每次迭代的话，都会重新进行赋值

const是一个常量   但是如果是一个对象的话，可以改变对象的属性值

#### css3中的box-sizing 的理解

一共有三个值     分别是   content-box    只计算内容  

​					padding-box    吧padding计算在呢

​						border-box    吧padding和border都包括在内

#### 说说h5中有趣的标签

如果标签语义话，有利于SEO（搜索引擎优化）,搜索引擎会很容易读懂网页要表达的意思    例如文本模块就要使用标题h1 -- h6 列表标签要使用ul和ol ，总要的文字用strong。  总之要充分利用html标签完成他们的本职工作

#### js实现继承有那些方式

借用构造函数实现继承

```js
function person(){
    this.name = 'person1'
}
function child(){
    person1.call(this)
  	this.type = 'child'
}
实现的是部分继承
```

借用原型链实现继承(原型对象的属性是共享的

混合式继承

#### 当new Foo()时发生了什么

创建了一个新对象  

将this指向这个新对象

执行构造函数里面的代码

返回新对象（this）

#### 同源和跨域

限制从一个源加载的文档或脚本 如何与另外一个源的资源进行交互。

一个源指的是主机名，协议和端口好的组合，必须相同

jsonp 基本原理: 利用script标签的异步特性实现

​				给服务器传一个回掉函数，服务器返回一个传递过去的回调过去的回掉函数名称的js代码；

原型和闭包的相关问题？

#### 原型是什么？

原型是一个普通的对象，每一个对象都有一个原型，原型能存储我们的方法，构造函数创建出来的实例对象能够应用原型中的方法。

#### 查看原型 

  以前的时候使用的是__proto__属性，es6用的是Object.getPrototypeof();方法来获取对象的原型，

#### 闭包是什么

当一个内部函数被其外部函数之外的变量掉用时，就形成了一个闭包；

闭包的特性

1.函数嵌套函数

2.函数内部可以应用外部的参数和变量

3.参数和变量不会被垃圾回收机制回收。

使用场景

希望在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会污染全局变量。

用一个例子来显示背包

```js
function foo(){
    var a = 2;
  	function bar(){
        console.log(a);
    }
  	return bar;
}
var baz = foo();
baz();
```

#### call方法和apply方法的区别

语法：call(thisobj)

​		调用对象的一个方法，以另一个对象代替当前对象

​		说明:  call方法可以用来代替另一个对象调用一个方法。call方法可以讲一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。

​		如果没有		

#### session和cookies的使用手记

###### 浏览器和服务器之间的数据交互，就是会话

http协议是一种无状态协议，假如你在a网站登录，逗你跳转到另一个页面的时候你的登录名并不会被保存，那么我们怎么让浏览器识别你的身份，认为你是同一个用户的多次请求呢，这里就要用到会话技术，本质上就是数据的持久化存储 

会话技术：就是用来解决http的缺陷而导致业务不连续的问题

cookies :4k    是浏览器端的存储

localstorage :5m;	 本地存储   只要用户不手动删除。就会一直存在，比如说: 记住皮肤，浏览器历史存储，回到上一次离开的位置等

sessionstorage:20m     浏览器关闭后没有了  单页面应用间数据的传递。

### cookies的过程分析

当浏览器请求xxx网站服务器的时候，服务器首先把数据存储在浏览器的cookie中

后来的每次请求，浏览器都会携带该网站内的所有cookie作为身份，有服务器脚本来识别处理

当然这一过程是基于浏览器执行的。同一个网站在不同的浏览器间存储的cookies是不能共享的



cookie默认是会话周期，即从浏览器打开，请求服务器资源，到关闭浏览器的这一过程

cookie因为存储在客户端而又安全性的问题，且每次请求都会携带cookie的所有的内容

cookie的使用

```js
setcookie('数据名','数据值'，'有效期','有效路径'，'有效域名')；
//      PHP_INTMAAX 永久有效    / 默认是当前目录及其子目录有效  .67585591.com 默认是当前域名
setcookie('age','18','PHP_INTMAX','/','.6758591.com');
//增加
setcookie('name','Lin');
//删除
setcookies('name','',0);
setcookies('name,'',time()-1);
//修改
setcookie('name','bin');
//查
echo $_COOKIES['name'];

```

##### session过程分析

 浏览器，首次 请求XXX服务器的时候服务器因session_start()而立即创建新的session文件

文件默认格式，示例：sess_014jphu0c88imka6242po5763  sess_是前缀，后面的字符是根据算法自动生成的具有唯一随机性的串儿。

通过http协议的响应头，setcookie去回传PHPSEESIONID=014jphu0c88lmka6242po5763

浏览器收到响应信息内容后，将PHPSESSION作为身份信息，保存在cookie，默认是会话周期

后来的每次请求都会携带所有的cookie信息，提交给服务器脚本；

服务器收到请求后，对比查找是否有对应的session文件，如果有的话则读取到超群居变量$_SESSION

中；

否则会创建session文件，以进行$_SESSION操作。

备注:session文件也不是一直存储在服务器端的，默认存储时间是24min

默认以文件形式存储，也可以存储在DB中，但读取操作还要消耗服务器资源的。

由php。ini中可的相关参数决定存活时间、启动gc的几率、session_name命名及存储位置等。

使用

```php
/*session*/
//当前页面开启session会话机制。（只要用到页面，就一定要首先开启。）
session_start();
//增
$session['name'] = 'lin';
//删除
unset($_SESSION['name']);      //删除是单个session数据
$_SESSION = [];               //删除的是全部的session数据
session_destroy();          //session文件都销毁
//查
echo $_SESSION['name'];
```

#### 返回结果的http状态码

200 ok 表示请求在服务器端被正常处理

204 No Content  请求被正常处理，但是返回的响应报文中不含实体的主题部分